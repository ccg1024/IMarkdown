import { app, BrowserWindow, dialog, Menu, protocol, ipcMain } from 'electron'
import path from 'path'

// custom import
import ipcConfig from './config/ipc.config'
import createMenus from './window/menu/menu'
import { defaultAppDirectory, closeMessage, MarkFile } from './window/tools'
import {
  FileCache,
  FileData,
  OpenFileType,
  UpdateFileType
} from './window/menu/menu-callback'
import { mountIPC } from './window/ipc'
import {
  getFileCacheProxyHandler,
  touchFileCacheItemProxyHandler,
  touchFileCacheProxyHandler
} from './window/proxy'
import { HeadInfo } from './types/main'

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit()
}

// custom code
const LOG_NAME = 'imarkdown.log'
const CONFIG_NAME = 'imarkdown.json'

let fileCache: FileCache = {}
let currentFilePath: string = ''
let win: BrowserWindow | null = null

export function hasCache(filepath: string): boolean {
  return fileCache.hasOwnProperty(filepath)
}
// NOTE: just readonly
export function touchFileCacheItem(filepath: string) {
  if (fileCache.hasOwnProperty(filepath)) {
    const handler = touchFileCacheItemProxyHandler<OpenFileType>()
    return new Proxy(fileCache[filepath], handler)
  }
  return null
}
// NOTE: just readonly
// would throw error if try to set value
export function touchFileCache() {
  const handler = touchFileCacheProxyHandler<FileCache>()
  return new Proxy(fileCache, handler)
}
export function addFileCache(filepath: string, file: OpenFileType) {
  if (filepath && file) {
    fileCache[filepath] = file
  }
}
// PERF: could be optimazed
export function updateFileCache(filepath: string, updater: UpdateFileType) {
  if (filepath) {
    const { fileInfo, fileData } = updater

    if (fileInfo) {
      let key: keyof MarkFile
      for (key in fileInfo) {
        fileCache[filepath].fileInfo[key] = fileInfo[key]
      }
    }
    if (fileData) {
      const { headInfo, ...rest } = fileData
      const { headInfo: _headInfo_, ..._rest_ } = fileCache[filepath].fileData

      if (headInfo) {
        let key: keyof HeadInfo
        for (key in headInfo) {
          _headInfo_[key] = headInfo[key]
        }
      }
      if (rest) {
        let key: keyof Omit<FileData, 'headInfo'>
        for (key in rest) {
          ;(_rest_ as any)[key] = rest[key]
        }
      }
      // mount update
      fileCache[filepath].fileData = { headInfo: _headInfo_, ..._rest_ }
    }
  }
}
// NOTE: duplicate
// since not a good idea for merge set and update function
export function mountFileCache() {
  const fileCacheHandler: ProxyHandler<FileCache> = getFileCacheProxyHandler()

  return new Proxy(fileCache, fileCacheHandler)
}

export function touchCurrentFile() {
  return currentFilePath
}
export function setCurrentFile(filepath: string) {
  if (filepath) {
    currentFilePath = filepath
  }
}
export function touchWin() {
  return win
}
export function touchEnvName() {
  return {
    logName: LOG_NAME,
    configName: CONFIG_NAME,
    configDir,
    logDir
  }
}

// generate default app directory
const { configDir, logDir } = defaultAppDirectory()

const createWindow = (): void => {
  // Create the browser window.
  fileCache = {}
  currentFilePath = ''

  const mainWindow = new BrowserWindow({
    icon: path.join(__dirname, './icons/markdown.ico'),
    width: 1280,
    height: 700,
    minWidth: 800,
    minHeight: 400,
    frame: false,
    titleBarStyle: 'hidden',
    vibrancy: 'under-window',
    visualEffectState: 'active',
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: true,
      contextIsolation: true
    }
  })

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

  // Open the DevTools.
  // mainWindow.webContents.openDevTools()
  win = mainWindow
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow)
app.whenReady().then(() => {
  protocol.registerFileProtocol('atom', (request, callback) => {
    let url = request.url.substring(7)
    if (url.startsWith('.') && currentFilePath) {
      url = path.join(path.dirname(currentFilePath), url)
    }
    callback(decodeURI(path.normalize(url)))
  })

  // some ipc event
  mountIPC()

  // listen close app event
  win?.on('close', function (e) {
    let showCloseDialog = false
    for (const key in fileCache) {
      if (fileCache[key].fileData.isChange === true) {
        showCloseDialog = true
        break
      }
    }

    if (showCloseDialog) {
      const res = dialog.showMessageBoxSync(this, closeMessage)
      if (res === 1) {
        e.preventDefault()
      }
    }
  })

  // create a menu
  const menuTemplate = createMenus()
  const menu = Menu.buildFromTemplate(menuTemplate)
  Menu.setApplicationMenu(menu)

  // show menu when click menu icon in title bar
  ipcMain.on(ipcConfig.SHOW_MENU, function (_, args) {
    if (win) {
      menu.popup({
        window: win,
        x: args.x,
        y: args.y
      })
    }
  })
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
})

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
